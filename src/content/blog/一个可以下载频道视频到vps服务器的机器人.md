---
author: xxxu
pubDatetime: 2025-01-16T10:20:35Z
modDatetime: 2025-01-16T10:20:35Z
title: ä¸€ä¸ªå¯ä»¥ä¸‹è½½é¢‘é“è§†é¢‘åˆ°vpsæœåŠ¡å™¨çš„æœºå™¨äºº
slug:  ä¸€ä¸ªå¯ä»¥ä¸‹è½½é¢‘é“è§†é¢‘åˆ°vpsæœåŠ¡å™¨çš„æœºå™¨äºº-blog
featured: false
draft: false
tags:
  - è½¯ä»¶
  - å¼€æº
description:
  ä¸€ä¸ªå¯ä»¥ä¸‹è½½é¢‘é“è§†é¢‘åˆ°vpsæœåŠ¡å™¨çš„æœºå™¨äºº
---

# Telegram è§†é¢‘ä¸‹è½½æœºå™¨äºº

ä¸€ä¸ªç”¨äºè‡ªåŠ¨ä¸‹è½½ Telegram é¢‘é“è§†é¢‘çš„æœºå™¨äººã€‚æ”¯æŒå¤§æ–‡ä»¶ä¸‹è½½ã€è¿›åº¦æ˜¾ç¤ºå’Œå¤šé¢‘é“ç›‘æ§ã€‚

åœ¨å½“ä»Šæ•°å­—æ—¶ä»£ï¼ŒTelegram å·²æˆä¸ºé‡è¦çš„ä¿¡æ¯ä¼ æ’­å¹³å°ï¼Œå¤§é‡ä¼˜è´¨è§†é¢‘å†…å®¹é€šè¿‡å„ç±»é¢‘é“è¿›è¡Œåˆ†äº«ã€‚ç„¶è€Œï¼Œè¿™äº›å†…å®¹å¾€å¾€å…·æœ‰æ—¶æ•ˆæ€§ï¼Œå¯èƒ½éšæ—¶è¢«åˆ é™¤æˆ–æ— æ³•è®¿é—®ã€‚åŒæ—¶ï¼Œåœ¨ç½‘ç»œæ¡ä»¶ä¸ç¨³å®šçš„æƒ…å†µä¸‹ï¼Œç›´æ¥è§‚çœ‹åœ¨çº¿è§†é¢‘ä¹Ÿä¼šé‡åˆ°è¯¸å¤šä¸ä¾¿ã€‚

## å¼€å‘åŠ¨æœº

1. **å†…å®¹ä¿å­˜éœ€æ±‚**
   
   - ä¼˜è´¨è§†é¢‘å†…å®¹çš„æœ¬åœ°å­˜æ¡£éœ€æ±‚
   - é¿å…å†…å®¹å¤±æ•ˆæˆ–è¢«åˆ é™¤çš„é£é™©
   - æ–¹ä¾¿ç¦»çº¿è§‚çœ‹å’ŒäºŒæ¬¡ä½¿ç”¨
2. **æŠ€æœ¯æŒ‘æˆ˜**
   
   - Telegram API çš„ä½¿ç”¨é™åˆ¶
   - å¤§æ–‡ä»¶ä¸‹è½½çš„æŠ€æœ¯éš¾ç‚¹
   - å¤šä»»åŠ¡å¹¶å‘å¤„ç†çš„éœ€æ±‚
3. **ç”¨æˆ·ç—›ç‚¹**
   
   - æ‰‹åŠ¨ä¸‹è½½è´¹æ—¶è´¹åŠ›
   - æ— æ³•æ‰¹é‡å¤„ç†è§†é¢‘æ–‡ä»¶
   - ä¸‹è½½è¿›åº¦æ— æ³•å®æ—¶ç›‘æ§
   - å­˜å‚¨ç®¡ç†ä¸å¤Ÿä¾¿æ·

## è§£å†³æ–¹æ¡ˆ

æœ¬é¡¹ç›®é€šè¿‡ä»¥ä¸‹æ–¹å¼è§£å†³è¿™äº›é—®é¢˜ï¼š

1. **è‡ªåŠ¨åŒ–å¤„ç†**
   
   - è‡ªåŠ¨ç›‘æ§æŒ‡å®šé¢‘é“
   - è‡ªåŠ¨è¯†åˆ«è§†é¢‘å†…å®¹
   - è‡ªåŠ¨ä¸‹è½½å¹¶åˆ†ç±»å­˜å‚¨
2. **ç”¨æˆ·å‹å¥½**
   
   - ç®€å•çš„å‘½ä»¤è¡Œæ¥å£
   - å®æ—¶è¿›åº¦æ˜¾ç¤º
   - å®Œæ•´çš„çŠ¶æ€åé¦ˆ
   - çµæ´»çš„é¢‘é“ç®¡ç†
3. **ç¨³å®šå¯é **
   
   - æ–­ç‚¹ç»­ä¼ æ”¯æŒ
   - è‡ªåŠ¨é‡è¯•æœºåˆ¶
   - é”™è¯¯å¤„ç†å®Œå–„
   - æ—¥å¿—è®°å½•è¯¦ç»†

## æŠ€æœ¯ç‰¹ç‚¹

1. **æ ¸å¿ƒåŠŸèƒ½**
   
   - åŸºäº Telethon åº“å¼€å‘
   - å¼‚æ­¥å¤„ç†æ¶æ„
   - å¤šä»»åŠ¡å¹¶å‘æ”¯æŒ
   - å®Œæ•´çš„é”™è¯¯å¤„ç†
2. **å®ç”¨ç‰¹æ€§**
   
   - å¤§æ–‡ä»¶æ”¯æŒ
   - è¿›åº¦æ˜¾ç¤º
   - çŠ¶æ€ç»Ÿè®¡
   - é…ç½®æŒä¹…åŒ–
3. **æ‰©å±•æ€§**
   
   - æ¨¡å—åŒ–è®¾è®¡
   - é…ç½®çµæ´»
   - æ˜“äºç»´æŠ¤
   - æ”¯æŒäºŒæ¬¡å¼€å‘

## åº”ç”¨åœºæ™¯

1. **ä¸ªäººç”¨æˆ·**
   
   - æ•™è‚²è§†é¢‘æ”¶è—
   - å­¦ä¹ èµ„æ–™å­˜æ¡£
   - å…´è¶£å†…å®¹ä¿å­˜
2. **å†…å®¹åˆ›ä½œè€…**
   
   - ç´ ææ”¶é›†æ•´ç†
   - ä½œå“å¤‡ä»½å­˜æ¡£
   - èµ„æºç®¡ç†å·¥å…·
3. **å›¢é˜Ÿåä½œ**
   
   - è§†é¢‘èµ„æºå…±äº«
   - å†…å®¹åˆ†å‘ç®¡ç†
   - ååŒå·¥ä½œæ”¯æŒ

## æœªæ¥å±•æœ›

1. **åŠŸèƒ½å¢å¼º**
   
   - æ”¯æŒæ›´å¤šåª’ä½“ç±»å‹
   - æ·»åŠ æ–‡ä»¶åˆ†ç±»åŠŸèƒ½
   - ä¼˜åŒ–å­˜å‚¨ç®¡ç†
   - å¢åŠ æ‰¹å¤„ç†èƒ½åŠ›
2. **ç”¨æˆ·ä½“éªŒ**
   
   - æ·»åŠ  Web ç•Œé¢
   - ä¼˜åŒ–è¿›åº¦æ˜¾ç¤º
   - å¢åŠ æ•°æ®ç»Ÿè®¡
   - æä¾›æ›´å¤šè‡ªå®šä¹‰é€‰é¡¹
3. **æŠ€æœ¯ä¼˜åŒ–**
   
   - æå‡ä¸‹è½½é€Ÿåº¦
   - ä¼˜åŒ–å†…å­˜ä½¿ç”¨
   - å¢å¼ºç¨³å®šæ€§
   - å®Œå–„é”™è¯¯å¤„ç†

## é¡¹ç›®ä»·å€¼

1. **å®ç”¨ä»·å€¼**
   
   - æé«˜å·¥ä½œæ•ˆç‡
   - èŠ‚çœäººåŠ›æˆæœ¬
   - ä¿æŠ¤é‡è¦å†…å®¹
   - ä¾¿äºèµ„æºç®¡ç†
2. **æŠ€æœ¯ä»·å€¼**
   
   - Telegram API åº”ç”¨ç¤ºä¾‹
   - å¼‚æ­¥ç¼–ç¨‹å®è·µ
   - æ–‡ä»¶å¤„ç†å‚è€ƒ
   - å¼€æºç¤¾åŒºè´¡çŒ®
3. **æ•™è‚²ä»·å€¼**
   
   - Python å­¦ä¹ èµ„æº
   - API ä½¿ç”¨ç¤ºä¾‹
   - é¡¹ç›®å®è·µå‚è€ƒ
   - å¼€æºåä½œç»éªŒ

## ç»“è¯­

æœ¬é¡¹ç›®æ—¨åœ¨è§£å†³ Telegram è§†é¢‘ä¸‹è½½çš„å®é™…éœ€æ±‚ï¼Œé€šè¿‡æŠ€æœ¯æ‰‹æ®µæé«˜æ•ˆç‡ï¼Œä¸ºç”¨æˆ·æä¾›ä¾¿æ·çš„å†…å®¹ç®¡ç†å·¥å…·ã€‚æˆ‘ä»¬æ¬¢è¿ç¤¾åŒºçš„è´¡çŒ®å’Œå»ºè®®ï¼Œå…±åŒæ¨åŠ¨é¡¹ç›®çš„å‘å±•å’Œå®Œå–„ã€‚

## åŠŸèƒ½ç‰¹ç‚¹

- ğŸ¥ è‡ªåŠ¨ä¸‹è½½é¢‘é“ä¸­çš„è§†é¢‘æ–‡ä»¶
- ğŸ“Š å®æ—¶æ˜¾ç¤ºä¸‹è½½è¿›åº¦å’Œé€Ÿåº¦
- ğŸ“ æ”¯æŒå¤§æ–‡ä»¶ä¸‹è½½
- ğŸ“‹ å¤šé¢‘é“ç›‘æ§ç®¡ç†
- ğŸ”„ è‡ªåŠ¨é‡è¯•å’Œæ–­ç‚¹ç»­ä¼ 
- ğŸ“ˆ ä¸‹è½½ç»Ÿè®¡å’ŒçŠ¶æ€æŸ¥çœ‹
  
  ![](https://image.xxxu.me/rest/zxk2cNK.png)
  ![](https://image.xxxu.me/rest/QcR2cNK.png)

## [githubåœ°å€](https://github.com/xxxume/telegram_video_downloader)

## å®‰è£…æ­¥éª¤

### 1.åˆ›å»º/root/videoç›®å½•

### 2.ä¸‹è½½[æ–‡ä»¶](https://github.com/xxxume/telegram_video_downloader/releases/tag/%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E9%A2%91%E9%81%93%E8%A7%86%E9%A2%91%E5%88%B0vps%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA)ä¸Šä¼ åˆ°/root/videoç›®å½•ä¸‹

### 3.åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ

```
python3 -m venv venv
source venv/bin/activate
```

### 4.å®‰è£…ä¾èµ–

```
pip install telethon humanize
```

### 5.åˆ›å»ºå¿…è¦çš„ç›®å½•ï¼š

```
mkdir -p logs session data
```

### 6.è®¾ç½®æƒé™ï¼š

```
chmod +x start\_bot.sh
```

## é…ç½®è¯´æ˜

1. ä» @BotFather è·å– Bot Token
2. ä» @userinfobot è·å–ä½ çš„ç”¨æˆ· ID
3. ä¿®æ”¹ `telegram_video_downloader.py` ä¸­çš„é…ç½®ï¼š
   - BOT_TOKEN
   - ADMIN_USER_ID

## ä½¿ç”¨æ–¹æ³•

å¯åŠ¨æœºå™¨äººï¼šscreen -S telegram-bot ./start\_bot.sh   #ï¼ˆæŒ‰ Ctrl+A+D å°†ç¨‹åºæ”¾å…¥åå°è¿è¡Œï¼‰

## æœºå™¨äººå‘½ä»¤

- `/start` - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
- `/add_channel @channel` - æ·»åŠ è¦ç›‘æ§çš„é¢‘é“
- `/remove_channel @channel` - ç§»é™¤ç›‘æ§çš„é¢‘é“
- `/list_channels` - åˆ—å‡ºæ‰€æœ‰ç›‘æ§çš„é¢‘é“
- `/status` - æŸ¥çœ‹ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯
  ***åˆæ¬¡ä½¿ç”¨éœ€è¦/add_channel @ä½ çš„é¢‘é“ç”¨æˆ·å    æ·»åŠ ç›‘æ§é¢‘é“ã€‚

## å¸¸ç”¨å‘½ä»¤

# æŸ¥çœ‹æ—¥å¿—

tail -f logs/bot.log

# æŸ¥çœ‹ screen ä¼šè¯

screen -ls

# é‡æ–°è¿æ¥åˆ° screen ä¼šè¯

screen -r telegram-bot

# åœæ­¢æœºå™¨äºº

screen -X -S telegram-bot quit

## æ³¨æ„äº‹é¡¹

1. ç¡®ä¿æœºå™¨äººæ˜¯é¢‘é“çš„ç®¡ç†å‘˜
2. å®šæœŸæ¸…ç†ä¸‹è½½ç›®å½•é¿å…ç©ºé—´ä¸è¶³
3. æ£€æŸ¥æ—¥å¿—åŠæ—¶å‘ç°é—®é¢˜
4. å»ºè®®è®¾ç½®è‡ªåŠ¨å¤‡ä»½

## æ•…éšœæ’é™¤

1. å¦‚æœæœºå™¨äººæ— å“åº”ï¼š
   
   - æ£€æŸ¥æ—¥å¿—æ–‡ä»¶
   - ç¡®è®¤ç½‘ç»œè¿æ¥
   - éªŒè¯ Bot Token æ˜¯å¦æ­£ç¡®
2. å¦‚æœä¸‹è½½å¤±è´¥ï¼š
   
   - æ£€æŸ¥å­˜å‚¨ç©ºé—´
   - ç¡®è®¤æ–‡ä»¶å¤§å°é™åˆ¶
   - æŸ¥çœ‹é”™è¯¯æ—¥å¿—
3. å¦‚æœéœ€è¦é‡ç½®ï¼š
   
   - åœæ­¢æœºå™¨äºº
   - æ¸…ç† session ç›®å½•
   - é‡æ–°å¯åŠ¨

## æ›´æ–°æ—¥å¿—

### v1.0.0

- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ
- æ”¯æŒåŸºæœ¬çš„è§†é¢‘ä¸‹è½½åŠŸèƒ½
- æ·»åŠ è¿›åº¦æ˜¾ç¤º
- æ”¯æŒå¤§æ–‡ä»¶ä¸‹è½½
  
  ## æ–‡ä»¶åˆ†äº«
  
 start_bot.sh

```
#!/bin/bash
cd /root/video
source venv/bin/activate

while true; do
    echo "Starting bot..."
    python telegram_video_downloader.py >> /root/video/logs/bot.out 2>&1
    echo "Bot crashed or stopped, restarting in 10 seconds..."
    sleep 10
done
```

telegram_bot_downloader.py

```
import os
import asyncio
from datetime import datetime
import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.error import TimedOut, NetworkError
import httpx
import time
import json
import math
import humanize  # éœ€è¦å®‰è£…: pip install humanize

# é…ç½®æ—¥å¿—
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('/root/video/bot.log'),  # æ·»åŠ æ–‡ä»¶æ—¥å¿—
        logging.StreamHandler()  # ä¿ç•™æ§åˆ¶å°è¾“å‡º
    ]
)
logger = logging.getLogger(__name__)

# Telegram Boté…ç½®
BOT_TOKEN = 'å¡«å…¥æœºå™¨äººçš„TOKEN'
ADMIN_USER_ID = å¡«å…¥ä½ çš„ç”¨æˆ·ID
BASE_URL = "https://api.telegram.org/bot"  # å¯ä»¥æ ¹æ®éœ€è¦ä¿®æ”¹ä¸ºå…¶ä»– API åœ°å€

# è§†é¢‘ä¿å­˜è·¯å¾„
DOWNLOAD_PATH = '/root/video'
os.makedirs(DOWNLOAD_PATH, exist_ok=True)

# å­˜å‚¨è¢«ç›‘æ§çš„é¢‘é“
monitored_channels = set()

# æ·»åŠ é…ç½®æ–‡ä»¶ä¿å­˜/åŠ è½½åŠŸèƒ½
def save_channels():
    with open('/root/video/channels.json', 'w') as f:
        json.dump(list(monitored_channels), f)
    logger.info(f"ä¿å­˜é¢‘é“é…ç½®: {monitored_channels}")

def load_channels():
    try:
        with open('/root/video/channels.json', 'r') as f:
            channels = json.load(f)
            monitored_channels.update(channels)
            logger.info(f"åŠ è½½é¢‘é“é…ç½®: {monitored_channels}")
    except FileNotFoundError:
        logger.info("æ²¡æœ‰æ‰¾åˆ°é¢‘é“é…ç½®æ–‡ä»¶")

# æ·»åŠ è¿›åº¦æ¡è¾…åŠ©å‡½æ•°
def create_progress_bar(progress):
    """åˆ›å»ºè¿›åº¦æ¡"""
    filled = 'â–ˆ' * int(progress * 10)
    empty = 'â–‘' * (10 - int(progress * 10))
    return f"{filled}{empty}"

def format_size(size):
    """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
    return humanize.naturalsize(size, binary=True)

async def progress_callback(current, total, message, start_time, file_name):
    """æ›´æ–°ä¸‹è½½è¿›åº¦"""
    try:
        now = time.time()
        # æ¯2ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦ï¼Œé¿å…é¢‘ç¹æ›´æ–°
        if now - progress_callback.last_update < 2:
            return
        progress_callback.last_update = now

        progress = current / total
        bar = create_progress_bar(progress)
        percentage = progress * 100
        
        # è®¡ç®—é€Ÿåº¦å’Œå‰©ä½™æ—¶é—´
        elapsed_time = now - start_time
        speed = current / elapsed_time if elapsed_time > 0 else 0
        eta = (total - current) / speed if speed > 0 else 0
        
        # æ ¼å¼åŒ–æ¶ˆæ¯
        text = (
            f"ğŸ“¥ æ­£åœ¨ä¸‹è½½: {file_name}\n"
            f"è¿›åº¦: {bar} {percentage:.1f}%\n"
            f"å¤§å°: {format_size(current)}/{format_size(total)}\n"
            f"é€Ÿåº¦: {format_size(speed)}/s\n"
            f"é¢„è®¡å‰©ä½™æ—¶é—´: {int(eta)}ç§’"
        )
        
        # æ›´æ–°æ¶ˆæ¯
        await message.edit_text(text)
    except Exception as e:
        logger.error(f"æ›´æ–°è¿›åº¦æ—¶å‡ºé”™: {str(e)}")

# åˆå§‹åŒ–æœ€åæ›´æ–°æ—¶é—´
progress_callback.last_update = 0

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† /start å‘½ä»¤"""
    logger.info(f"Received /start command from user ID: {update.effective_user.id}")
    
    if update.effective_user.id != ADMIN_USER_ID:
        logger.warning(f"Unauthorized access attempt from user {update.effective_user.id}")
        await update.message.reply_text("æŠ±æ­‰ï¼Œæ‚¨æ²¡æœ‰ä½¿ç”¨æ­¤æœºå™¨äººçš„æƒé™ã€‚")
        return
    
    logger.info("Sending welcome message to admin")
    await update.message.reply_text(
        "æ¬¢è¿ä½¿ç”¨é¢‘é“è§†é¢‘ä¸‹è½½æœºå™¨äººï¼\n"
        "/add_channel <é¢‘é“é“¾æ¥> - æ·»åŠ è¦ç›‘æ§çš„é¢‘é“\n"
        "/remove_channel <é¢‘é“é“¾æ¥> - ç§»é™¤ç›‘æ§çš„é¢‘é“\n"
        "/list_channels - åˆ—å‡ºæ‰€æœ‰ç›‘æ§çš„é¢‘é“\n"
        "/status - æŸ¥çœ‹ä¸‹è½½çŠ¶æ€å’Œç»Ÿè®¡ä¿¡æ¯"
    )

async def add_channel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ·»åŠ è¦ç›‘æ§çš„é¢‘é“"""
    if update.effective_user.id != ADMIN_USER_ID:
        return
    
    if not context.args:
        await update.message.reply_text("è¯·æä¾›é¢‘é“ç”¨æˆ·åï¼Œä¾‹å¦‚: /add_channel @channel_name")
        return
    
    channel = context.args[0].strip('@')
    try:
        # éªŒè¯é¢‘é“
        chat = await context.bot.get_chat(f"@{channel}")
        if chat.type != 'channel':
            await update.message.reply_text("è¿™ä¸æ˜¯ä¸€ä¸ªé¢‘é“")
            return
            
        # æ£€æŸ¥æœºå™¨äººæƒé™
        member = await chat.get_member(context.bot.id)
        if not member.status in ['administrator', 'creator']:
            await update.message.reply_text("è¯·å…ˆå°†æœºå™¨äººæ·»åŠ ä¸ºé¢‘é“ç®¡ç†å‘˜")
            return
        
        monitored_channels.add(channel)
        save_channels()  # ä¿å­˜é…ç½®
        await update.message.reply_text(f"å·²æˆåŠŸæ·»åŠ é¢‘é“: @{channel}\næœºå™¨äººå°†è‡ªåŠ¨ä¸‹è½½è¯¥é¢‘é“çš„æ–°è§†é¢‘")
        logger.info(f"Added channel: @{channel}")
        
    except Exception as e:
        error_message = str(e)
        logger.error(f"Failed to add channel {channel}: {error_message}")
        if "Chat not found" in error_message:
            await update.message.reply_text("æ‰¾ä¸åˆ°è¯¥é¢‘é“ï¼Œè¯·ç¡®ä¿:\n1. é¢‘é“ç”¨æˆ·åæ­£ç¡®\n2. é¢‘é“æ˜¯å…¬å¼€çš„\n3. æœºå™¨äººå·²åŠ å…¥è¯¥é¢‘é“")
        else:
            await update.message.reply_text(f"æ·»åŠ é¢‘é“å¤±è´¥: {error_message}\nè¯·ç¡®ä¿:\n1. é¢‘é“ç”¨æˆ·åæ­£ç¡®\n2. æœºå™¨äººæ˜¯é¢‘é“ç®¡ç†å‘˜")

async def remove_channel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç§»é™¤ç›‘æ§çš„é¢‘é“"""
    if update.effective_user.id != ADMIN_USER_ID:
        return
    
    if not context.args:
        await update.message.reply_text("è¯·æä¾›è¦ç§»é™¤çš„é¢‘é“é“¾æ¥æˆ–ç”¨æˆ·å")
        return
    
    channel = context.args[0]
    if channel.strip('@') in monitored_channels:
        monitored_channels.remove(channel.strip('@'))
        await update.message.reply_text(f"å·²ç§»é™¤é¢‘é“: {channel}")
    else:
        await update.message.reply_text("æœªæ‰¾åˆ°è¯¥é¢‘é“")

async def list_channels(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """åˆ—å‡ºæ‰€æœ‰ç›‘æ§çš„é¢‘é“"""
    if update.effective_user.id != ADMIN_USER_ID:
        return
    
    if not monitored_channels:
        await update.message.reply_text("å½“å‰æ²¡æœ‰ç›‘æ§ä»»ä½•é¢‘é“")
        return
    
    channels_list = "\n".join(f"- {channel}" for channel in monitored_channels)
    await update.message.reply_text(f"å½“å‰ç›‘æ§çš„é¢‘é“ï¼š\n{channels_list}")

async def handle_new_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æ–°æ¶ˆæ¯ï¼Œä¸‹è½½è§†é¢‘"""
    logger.info("æ”¶åˆ°æ–°æ¶ˆæ¯")
    
    if not update.channel_post:
        logger.info("ä¸æ˜¯é¢‘é“æ¶ˆæ¯ï¼Œå¿½ç•¥")
        return
    
    channel_username = update.effective_chat.username
    logger.info(f"æ¶ˆæ¯æ¥è‡ªé¢‘é“: {channel_username}")
    
    if channel_username not in monitored_channels:
        logger.info(f"é¢‘é“ {channel_username} ä¸åœ¨ç›‘æ§åˆ—è¡¨ä¸­")
        return
    
    try:
        if update.channel_post.video:
            video = update.channel_post.video
            logger.info(f"æ£€æµ‹åˆ°è§†é¢‘: {video.file_name}, å¤§å°: {format_size(video.file_size)}")
            
            # ä¿®æ”¹æ–‡ä»¶å¤§å°é™åˆ¶æ£€æŸ¥
            if video.file_size > 50 * 1024 * 1024:  # 50MB
                error_msg = (
                    f"æ–‡ä»¶å¤ªå¤§ ({format_size(video.file_size)})ï¼Œè¶…è¿‡ Telegram Bot API é™åˆ¶\n"
                    f"å»ºè®®ï¼š\n"
                    f"1. ä½¿ç”¨è¾ƒå°çš„è§†é¢‘æ–‡ä»¶ï¼ˆ<50MBï¼‰\n"
                    f"2. æˆ–è€…å°†è§†é¢‘åˆ†æ®µä¸Šä¼ \n"
                    f"3. æˆ–è€…ä½¿ç”¨å…¶ä»–ä¸‹è½½æ–¹å¼"
                )
                logger.error(error_msg)
                await context.bot.send_message(
                    chat_id=ADMIN_USER_ID,
                    text=f"âŒ ä¸‹è½½å¤±è´¥\n"
                         f"é¢‘é“: @{channel_username}\n"
                         f"æ–‡ä»¶: {video.file_name}\n"
                         f"å¤§å°: {format_size(video.file_size)}\n"
                         f"åŸå› : æ–‡ä»¶è¶…è¿‡50MBé™åˆ¶"
                )
                return
            
            now = datetime.now().strftime('%Y%m%d_%H%M%S')
            file_name = video.file_name or f'video_{now}.mp4'
            file_path = os.path.join(DOWNLOAD_PATH, file_name)
            
            # ç¡®ä¿æ–‡ä»¶åå”¯ä¸€
            base_name, ext = os.path.splitext(file_name)
            counter = 1
            while os.path.exists(file_path):
                file_path = os.path.join(DOWNLOAD_PATH, f'{base_name}_{counter}{ext}')
                counter += 1
            
            # å‘é€åˆå§‹ä¸‹è½½æ¶ˆæ¯
            progress_message = await context.bot.send_message(
                chat_id=ADMIN_USER_ID,
                text=f"å¼€å§‹ä¸‹è½½è§†é¢‘: {file_name}\nå¤§å°: {format_size(video.file_size)}"
            )
            
            try:
                # è®°å½•å¼€å§‹æ—¶é—´
                start_time = time.time()
                
                # ä¸‹è½½è§†é¢‘
                logger.info(f'å¼€å§‹ä¸‹è½½è§†é¢‘: {file_path}')
                file = await context.bot.get_file(video.file_id)
                await file.download_to_drive(
                    custom_path=file_path,
                    progress_callback=lambda current, total: asyncio.create_task(
                        progress_callback(
                            current, total, progress_message, 
                            start_time, file_name
                        )
                    )
                )
                
                # ä¸‹è½½å®Œæˆåçš„å¤„ç†
                file_size = os.path.getsize(file_path)
                duration = time.time() - start_time
                average_speed = file_size / duration if duration > 0 else 0
                
                # å‘é€å®Œæˆæ¶ˆæ¯
                complete_message = (
                    f"âœ… è§†é¢‘ä¸‹è½½å®Œæˆ\n"
                    f"é¢‘é“: @{channel_username}\n"
                    f"æ–‡ä»¶: {file_name}\n"
                    f"å¤§å°: {format_size(file_size)}\n"
                    f"ç”¨æ—¶: {int(duration)}ç§’\n"
                    f"å¹³å‡é€Ÿåº¦: {format_size(average_speed)}/s"
                )
                
                await progress_message.edit_text(complete_message)
                logger.info(f'è§†é¢‘ä¸‹è½½å®Œæˆ: {file_path} ({format_size(file_size)})')
                
            except Exception as e:
                # å¦‚æœä¸‹è½½å¤±è´¥ï¼Œåˆ é™¤å¯èƒ½çš„éƒ¨åˆ†ä¸‹è½½æ–‡ä»¶
                if os.path.exists(file_path):
                    os.remove(file_path)
                raise e
                
        else:
            logger.info("æ¶ˆæ¯ä¸­æ²¡æœ‰è§†é¢‘")
            
    except Exception as e:
        error_message = f"ä¸‹è½½è§†é¢‘æ—¶å‡ºé”™: {str(e)}"
        logger.error(error_message)
        # é€šçŸ¥ç®¡ç†å‘˜å‡ºé”™
        await context.bot.send_message(
            chat_id=ADMIN_USER_ID,
            text=f"âŒ ä¸‹è½½å¤±è´¥\né¢‘é“: @{channel_username}\né”™è¯¯: {str(e)}"
        )

async def status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ˜¾ç¤ºä¸‹è½½çŠ¶æ€å’Œç»Ÿè®¡ä¿¡æ¯"""
    if update.effective_user.id != ADMIN_USER_ID:
        return
    
    try:
        # è·å–ä¸‹è½½ç›®å½•çš„ç»Ÿè®¡ä¿¡æ¯
        total_files = len([f for f in os.listdir(DOWNLOAD_PATH) if os.path.isfile(os.path.join(DOWNLOAD_PATH, f))])
        total_size = sum(os.path.getsize(os.path.join(DOWNLOAD_PATH, f)) for f in os.listdir(DOWNLOAD_PATH) if os.path.isfile(os.path.join(DOWNLOAD_PATH, f)))
        
        status_message = (
            "ğŸ“Š ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯\n"
            f"ç›‘æ§çš„é¢‘é“æ•°: {len(monitored_channels)}\n"
            f"å·²ä¸‹è½½æ–‡ä»¶æ•°: {total_files}\n"
            f"æ€»å­˜å‚¨å¤§å°: {total_size / 1024 / 1024:.2f} MB\n"
            f"å­˜å‚¨è·¯å¾„: {DOWNLOAD_PATH}"
        )
        await update.message.reply_text(status_message)
    except Exception as e:
        await update.message.reply_text(f"è·å–çŠ¶æ€ä¿¡æ¯æ—¶å‡ºé”™: {str(e)}")

def main():
    """å¯åŠ¨æœºå™¨äºº"""
    logger.info("Bot starting...")
    load_channels()  # åŠ è½½ä¿å­˜çš„é¢‘é“é…ç½®
    logger.info(f"Admin ID: {ADMIN_USER_ID}")
    logger.info(f"Download path: {DOWNLOAD_PATH}")
    logger.info(f"Monitored channels: {monitored_channels}")
    
    while True:
        try:
            # æ¯æ¬¡å¾ªç¯åˆ›å»ºæ–°çš„åº”ç”¨å®ä¾‹
            application = (
                Application.builder()
                .token(BOT_TOKEN)
                .connect_timeout(30.0)
                .read_timeout(30.0)
                .write_timeout(30.0)
                .pool_timeout(30.0)
                .get_updates_read_timeout(30.0)
                .build()
            )
            
            logger.info("Application built successfully")
            
            # æ³¨å†Œå‘½ä»¤å¤„ç†å™¨
            application.add_handler(CommandHandler("start", start))
            application.add_handler(CommandHandler("add_channel", add_channel))
            application.add_handler(CommandHandler("remove_channel", remove_channel))
            application.add_handler(CommandHandler("list_channels", list_channels))
            application.add_handler(CommandHandler("status", status))
            
            # æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
            application.add_handler(MessageHandler(
                filters.ChatType.CHANNEL & (filters.VIDEO | filters.FORWARDED),
                handle_new_message
            ))
            
            logger.info("All handlers registered")
            
            # å¯åŠ¨è½®è¯¢
            logger.info("Starting polling...")
            application.run_polling(
                allowed_updates=Update.ALL_TYPES,
                drop_pending_updates=True,
                timeout=30,
                read_timeout=30,
                write_timeout=30,
                connect_timeout=30,
                pool_timeout=30
            )
            
        except (TimedOut, NetworkError) as e:
            logger.error(f"Network error: {e}")
            logger.info("Waiting 10 seconds before retry...")
            time.sleep(10)
            continue
        except Exception as e:
            logger.error(f"Critical error: {str(e)}", exc_info=True)
            logger.info("Waiting 30 seconds before retry...")
            time.sleep(30)
            continue

if __name__ == '__main__':
    try:
        logger.info("Script started")
        main()
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Fatal error: {str(e)}", exc_info=True)
```

telegram_video_downloader.py

```
import os
import asyncio
from datetime import datetime
import logging
from telethon import TelegramClient, events
import humanize
import json
import time

# é…ç½®æ—¥å¿—
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('/root/video/logs/bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Telegram Boté…ç½®
BOT_TOKEN = os.getenv('BOT_TOKEN', '7701103060:AAEfjw6DUzRT3XSQwcTRROL2Q1I8Dkv1PKI')
ADMIN_USER_ID = int(os.getenv('ADMIN_USER_ID', '1824426271'))

# ä½¿ç”¨å…¬å…±æµ‹è¯•æœåŠ¡å™¨çš„ API ID å’Œ Hash
API_ID = 2040
API_HASH = "b18441a1ff607e10a989891a5462e627"

# è§†é¢‘ä¿å­˜è·¯å¾„
DOWNLOAD_PATH = '/root/video'
os.makedirs(DOWNLOAD_PATH, exist_ok=True)

# session æ–‡ä»¶è·¯å¾„
SESSION_PATH = '/root/video/session/bot_session'

# å­˜å‚¨è¢«ç›‘æ§çš„é¢‘é“
monitored_channels = set()

# ä¿å­˜å’ŒåŠ è½½é¢‘é“é…ç½®
def save_channels():
    with open('/root/video/channels.json', 'w') as f:
        json.dump(list(monitored_channels), f)
    logger.info(f"ä¿å­˜é¢‘é“é…ç½®: {monitored_channels}")

def load_channels():
    try:
        with open('/root/video/channels.json', 'r') as f:
            channels = json.load(f)
            monitored_channels.update(channels)
            logger.info(f"åŠ è½½é¢‘é“é…ç½®: {monitored_channels}")
    except FileNotFoundError:
        logger.info("æ²¡æœ‰æ‰¾åˆ°é¢‘é“é…ç½®æ–‡ä»¶")

def format_size(size):
    """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
    return humanize.naturalsize(size, binary=True)

async def progress_callback(current, total, message, start_time, file_name):
    """æ˜¾ç¤ºä¸‹è½½è¿›åº¦"""
    try:
        now = time.time()
        # æ¯2ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦
        if hasattr(progress_callback, 'last_update'):
            if now - progress_callback.last_update < 2:
                return
        progress_callback.last_update = now

        # è®¡ç®—è¿›åº¦
        percentage = (current / total) * 100
        speed = current / (now - start_time) if now - start_time > 0 else 0
        eta = (total - current) / speed if speed > 0 else 0

        # åˆ›å»ºè¿›åº¦æ¡
        bar_length = 10
        filled = int(percentage / 100 * bar_length)
        bar = 'â–ˆ' * filled + 'â–‘' * (bar_length - filled)

        # æ›´æ–°æ¶ˆæ¯
        await message.edit(
            f"ğŸ“¥ æ­£åœ¨ä¸‹è½½: {file_name}\n"
            f"è¿›åº¦: {bar} {percentage:.1f}%\n"
            f"å¤§å°: {format_size(current)}/{format_size(total)}\n"
            f"é€Ÿåº¦: {format_size(speed)}/s\n"
            f"é¢„è®¡å‰©ä½™æ—¶é—´: {int(eta)}ç§’"
        )
    except Exception as e:
        logger.error(f"æ›´æ–°è¿›åº¦æ—¶å‡ºé”™: {str(e)}")

async def main():
    try:
        # åˆ›å»ºå®¢æˆ·ç«¯
        logger.info("Creating client...")
        client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
        
        logger.info("Starting client with bot token...")
        await client.start(bot_token=BOT_TOKEN)
        
        logger.info("Bot started successfully")
        logger.info(f"Bot username: {(await client.get_me()).username}")
        
        # åŠ è½½ä¿å­˜çš„é¢‘é“é…ç½®
        load_channels()
        
        @client.on(events.NewMessage(pattern='/start'))
        async def start_handler(event):
            if event.sender_id != ADMIN_USER_ID:
                return
            
            await event.respond(
                "æ¬¢è¿ä½¿ç”¨é¢‘é“è§†é¢‘ä¸‹è½½æœºå™¨äººï¼\n"
                "/add_channel <é¢‘é“é“¾æ¥> - æ·»åŠ è¦ç›‘æ§çš„é¢‘é“\n"
                "/remove_channel <é¢‘é“é“¾æ¥> - ç§»é™¤ç›‘æ§çš„é¢‘é“\n"
                "/list_channels - åˆ—å‡ºæ‰€æœ‰ç›‘æ§çš„é¢‘é“\n"
                "/status - æŸ¥çœ‹ä¸‹è½½çŠ¶æ€å’Œç»Ÿè®¡ä¿¡æ¯"
            )

        @client.on(events.NewMessage(pattern='/add_channel'))
        async def add_channel_handler(event):
            if event.sender_id != ADMIN_USER_ID:
                return
            
            try:
                channel = event.text.split(maxsplit=1)[1].strip('@')
                entity = await client.get_entity(channel)
                if not hasattr(entity, 'broadcast'):
                    await event.respond("è¿™ä¸æ˜¯ä¸€ä¸ªé¢‘é“")
                    return
                
                monitored_channels.add(channel)
                save_channels()
                await event.respond(f"å·²æˆåŠŸæ·»åŠ é¢‘é“: @{channel}")
                logger.info(f"Added channel: @{channel}")
            except Exception as e:
                await event.respond(f"æ·»åŠ é¢‘é“å¤±è´¥: {str(e)}")
                logger.error(f"Failed to add channel: {str(e)}")

        @client.on(events.NewMessage(pattern='/remove_channel'))
        async def remove_channel_handler(event):
            if event.sender_id != ADMIN_USER_ID:
                return
            
            try:
                channel = event.text.split(maxsplit=1)[1].strip('@')
                if channel in monitored_channels:
                    monitored_channels.remove(channel)
                    save_channels()
                    await event.respond(f"å·²ç§»é™¤é¢‘é“: @{channel}")
                else:
                    await event.respond("æœªæ‰¾åˆ°è¯¥é¢‘é“")
            except Exception as e:
                await event.respond(f"ç§»é™¤é¢‘é“å¤±è´¥: {str(e)}")

        @client.on(events.NewMessage(pattern='/list_channels'))
        async def list_channels_handler(event):
            if event.sender_id != ADMIN_USER_ID:
                return
            
            if not monitored_channels:
                await event.respond("å½“å‰æ²¡æœ‰ç›‘æ§ä»»ä½•é¢‘é“")
                return
            
            channels_list = "\n".join(f"- {channel}" for channel in monitored_channels)
            await event.respond(f"å½“å‰ç›‘æ§çš„é¢‘é“ï¼š\n{channels_list}")

        @client.on(events.NewMessage(pattern='/status'))
        async def status_handler(event):
            if event.sender_id != ADMIN_USER_ID:
                return
            
            try:
                total_files = len([f for f in os.listdir(DOWNLOAD_PATH) if os.path.isfile(os.path.join(DOWNLOAD_PATH, f))])
                total_size = sum(os.path.getsize(os.path.join(DOWNLOAD_PATH, f)) for f in os.listdir(DOWNLOAD_PATH) if os.path.isfile(os.path.join(DOWNLOAD_PATH, f)))
                
                await event.respond(
                    "ğŸ“Š ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯\n"
                    f"ç›‘æ§çš„é¢‘é“æ•°: {len(monitored_channels)}\n"
                    f"å·²ä¸‹è½½æ–‡ä»¶æ•°: {total_files}\n"
                    f"æ€»å­˜å‚¨å¤§å°: {format_size(total_size)}\n"
                    f"å­˜å‚¨è·¯å¾„: {DOWNLOAD_PATH}"
                )
            except Exception as e:
                await event.respond(f"è·å–çŠ¶æ€ä¿¡æ¯æ—¶å‡ºé”™: {str(e)}")

        @client.on(events.NewMessage)
        async def download_handler(event):
            try:
                # æ·»åŠ æ›´å¤šæ—¥å¿—
                logger.info(f"Received message: {event.message.id}")
                
                if not event.is_channel:
                    logger.info("Not a channel message")
                    return
                
                channel_username = (await event.get_chat()).username
                logger.info(f"Message from channel: @{channel_username}")
                
                if channel_username not in monitored_channels:
                    logger.info(f"Channel @{channel_username} not in monitored list")
                    return

                if hasattr(event.message, 'media') and event.message.media:
                    logger.info("Message has media")
                    # è·å–è§†é¢‘ä¿¡æ¯
                    media = event.message.media
                    if hasattr(media, 'document'):
                        # è·å–æ–‡ä»¶ä¿¡æ¯
                        file_size = media.document.size
                        mime_type = media.document.mime_type
                        
                        # åªå¤„ç†è§†é¢‘æ–‡ä»¶
                        if not mime_type or not mime_type.startswith('video/'):
                            return
                        
                        # è·å–æ–‡ä»¶å
                        for attribute in media.document.attributes:
                            if hasattr(attribute, 'file_name') and attribute.file_name:
                                file_name = attribute.file_name
                                break
                        else:
                            file_name = f"video_{int(time.time())}.mp4"
                        
                        file_path = os.path.join(DOWNLOAD_PATH, file_name)
                        
                        # ç¡®ä¿æ–‡ä»¶åå”¯ä¸€
                        base_name, ext = os.path.splitext(file_name)
                        counter = 1
                        while os.path.exists(file_path):
                            file_path = os.path.join(DOWNLOAD_PATH, f"{base_name}_{counter}{ext}")
                            counter += 1
                        
                        # å‘é€å¼€å§‹ä¸‹è½½æ¶ˆæ¯
                        status_message = await client.send_message(
                            ADMIN_USER_ID,
                            f"å¼€å§‹ä¸‹è½½è§†é¢‘: {file_name}\nå¤§å°: {format_size(file_size)}"
                        )
                        
                        try:
                            # è®°å½•å¼€å§‹æ—¶é—´
                            start_time = time.time()
                            
                            # åˆ›å»ºè¿›åº¦å›è°ƒ
                            async def progress(current, total):
                                try:
                                    await progress_callback(current, total, status_message, start_time, file_name)
                                except Exception as e:
                                    logger.error(f"Progress callback error: {str(e)}")
                            
                            # ä¸‹è½½è§†é¢‘
                            await client.download_media(
                                message=event.message.media,
                                file=file_path,
                                progress_callback=progress
                            )
                            
                            # ä¸‹è½½å®Œæˆåçš„å¤„ç†
                            actual_size = os.path.getsize(file_path)
                            duration = time.time() - start_time
                            average_speed = actual_size / duration if duration > 0 else 0
                            
                            # å‘é€å®Œæˆæ¶ˆæ¯
                            await status_message.edit(
                                f"âœ… è§†é¢‘ä¸‹è½½å®Œæˆ\n"
                                f"é¢‘é“: @{channel_username}\n"
                                f"æ–‡ä»¶: {file_name}\n"
                                f"å¤§å°: {format_size(actual_size)}\n"
                                f"ç”¨æ—¶: {int(duration)}ç§’\n"
                                f"å¹³å‡é€Ÿåº¦: {format_size(average_speed)}/s"
                            )
                            
                            logger.info(f"è§†é¢‘ä¸‹è½½å®Œæˆ: {file_path}")
                            
                        except Exception as e:
                            # å¦‚æœä¸‹è½½å¤±è´¥ï¼Œåˆ é™¤éƒ¨åˆ†ä¸‹è½½çš„æ–‡ä»¶
                            if os.path.exists(file_path):
                                os.remove(file_path)
                            raise e
                            
            except Exception as e:
                error_msg = f"ä¸‹è½½è§†é¢‘æ—¶å‡ºé”™: {str(e)}"
                logger.error(error_msg)
                await client.send_message(
                    ADMIN_USER_ID, 
                    f"âŒ ä¸‹è½½å¤±è´¥\n"
                    f"é¢‘é“: @{channel_username}\n"
                    f"é”™è¯¯: {str(e)}"
                )

        try:
            logger.info("Starting bot...")
            await client.run_until_disconnected()
        except KeyboardInterrupt:
            logger.info("Bot stopped by user")
        except Exception as e:
            logger.error(f"Bot crashed: {str(e)}")
            raise

    except Exception as e:
        logger.error(f"Failed to start bot: {str(e)}", exc_info=True)
        raise

if __name__ == '__main__':
    try:
        logger.info("Script started")
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Fatal error: {str(e)}", exc_info=True) 
```

